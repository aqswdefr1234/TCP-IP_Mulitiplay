맨처음은 클라이언트 한명이 늘때마다 thread 개수를 하나씩 늘이고 while문을 사용하여 데이터를 받아왔음.
하지만 이것은 너무 많은 자원을 소모하므로 하나의 while문을 사용하여 foreach를 통해 전체 데이터를 읽고 쓰는 방향으로 수정.

이 알고리즘은 foreach를 통해 모든 클라이언트 데이터를 읽고, 종합하여 연결된 전체 클라이언트에게 보냄.
하지만 이 알고리즘은 한명이라도 네트워크 속도가 느리면 그 한명때문에 전체에게 발송되는 데이터가 지연되므로 단체로 느려지는 문제 있음.

그래서 !DataAvailalbe 이면 continue 를 사용하여 건너뛰는 코드로 수정.
하지만 이것은 클라이언트가 연결이 종료되었을 시에도 continue로 건너뛰므로 그것을 감지하지 못함.

그래서 클라이언트에게 메인서버에서 클라이언트 번호를 발송하고, 메인서버가 아닌 다른 서버로 클라이언트가 발급받은 번호를 보내면, 서버가 번호를 읽고 해당 클라이언트의 tcpclient와 networkstream을 번호와 함께 딕셔너리에 더함. 그리고 클라이언트의 데이터를 계속 받아오는 transform 데이터 서버에서 연결이 종료되면 딕셔너리들에서 해당 클라이언트의 번호에 해당하는 모든 서버와의 연결을 종료시킴.

하지만 최초 접속시 메인포트에서는 통신이 잘 되어서 메인서버 딕셔너리에 추가되었지만, 다른 포트에서의 연결이 실패하면 이 포트에서 열린 서버에서는 클라이언트의 번호에 대한 정보가 없으므로 딕셔너리에서 제외 할 수 없음.
그 때 모든 네트워크 딕셔너리를 검사하여 메인 서버딕셔너리에는 정보가 있지만, 다른 딕셔너리에는 정보가 없는 클라이언트 연결이 끊어줌.
